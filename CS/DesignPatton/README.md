1. [싱글톤 패턴](#1-싱글톤-패턴)
2. [팩토리 패턴](#2-팩토리-패턴)
3. [전략 패턴](#3-전략-패턴strategy-pattern)
4. [옵저버 패턴](#4-옵저버-패턴)
5. [프록시 패턴과 프록시 서버](#5-프록시-패턴과-프록시-서버)

### 라이브러리와 프레임워크

- 공통으로 사용될 수 있는 특정한 기능들을 모듈화 한 것

**라이브러리**

1. 폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유로움

**프레임워크**

1. 폴더명, 파일명 등에 대한 규칙이 있고, 라이브러리에 비해 엄격함.

> 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 규약 형태로 만들어 놓은 것.

## 1. 싱글톤 패턴

- 하나의 클래스에 오직 하나의 인스턴스만 가짐.
- DB 연결 모듈에 많이 사용
- 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용
  → 인스턴스 생성 비용이 줄어듬, 의존성이 높아짐

> **의존성이 높으면 왜 안좋아요?** <br>

    → A-B, B-C 로 연결되어 있을 경우, C가 변경되면 B와 A 모두 변경해줘야하는 번거로움이 발생함.
    → 유닛테스트 작성이 어려움. (다른 모듈로부터 독립적으로 테스트하는 것을 요구하기 때문)

### 단점

- TDD(Test Driven Development)를 할 때 걸림돌이 됨.

- 독립적이어야 단위 테스트를 어떤 순서로든 실행할 수 있어야하는데 독립적인 인스턴스를 만들기가 어려움.
  → 하나의 인스턴스를 기반으로 구현하는 패턴이기 때문

## 의존성 주입

모듈 간의 결합을 강하게 만들 수 있다는 단점도 있음.

따라서 의존성 주입(DI, Dependency Injection)을 통해 결합을 조금 더 느슨하게 만들어 해결할 수 있음.

`디커플링` 된다라고도 함.

### 장점

1. 모듈들을 쉽게 교체할 수 있는 구조가 됨

- 테스팅하기 쉽고 마이그레이션 수월함.

2. 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어줌.

- 애플리케이션 의존성 방향이 일관됨.
- 애플리케이션이 쉽게 추론할 수 있음
- 모듈 간의 관계들이 조금 더 명확해짐.

### 단점

1. 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있음.
2. 약간의 런타임 패널티가 생기기도 함.

### 원칙

1. 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다.
2. 둘 다 추상화에 의존해야 하며, 추상화는 세부 사항에 의존하지 말아야 한다.

---

## 2. 팩토리 패턴

- 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
- 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정
- 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴

상위 하위 클래스가 분리되기 때문에 `느슨한 결합`을 가짐

상위 클래스에서는 더 많은 `유연성`을 갖고 `유지 보수성`이 증가됨.

- 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에
- 객체 생성 로직이 따로 떼어져 있어 한 곳만 고칠 수 있음.

---

## 3. 전략 패턴(strategy pattern)

= 정책 패턴(policy pattern)

캡슐화한 알고리즘(`전략`)을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

- 컨텍스트

`상황`, `맥락`, `문맥`을 의미, 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보

### passport의 전략 패턴

Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리.

LocalStrategy 전략 - 서비스 내의 회원가입된 아이디와 비밀번호를 기반으로 인증

OAuth 전략 - 페이스북, 구글 등 다른 서비스를 기반으로 인증

`전략`을 매개변수로 넣어서 로직을 수행.

---

## 4. 옵저버 패턴

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴

Ex) 트위터

주체 : 객체의 상태 변화를 보고 있는 관찰자

옵저버 : 전달되는 메서드 등을 기반으로 `추가 변화 사항`이 생기는 객체들

주로 이벤트 기반 시스템에 사용하며, MVC 패턴에도 사용됨.

### JS에서 옵저버

프록시 객체를 통해 구현할 수 있음.

### 프록시 객체

어떠한 대상의 기본적인 동작의 작업을 가로챌 수 있는 객체

> 기본적인 동작 : 속성 접근, 할당, 순회, 열거, 함수 호출 등

- 두 개의 매개변수를 가짐

`target` : 프록시할 대상

`handler` : 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수

### 프록시 객체의 get(), has(), set()

`get() 함수` : 속성과 함수에 대한 접근을 가로챔

`has() 함수` : in 연산자의 사용을 가로챔

`set() 함수` : 속성에 대한 접근을 가로챔

---

## 5. 프록시 패턴과 프록시 서버

### 프록시 패턴

대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴

→ 객체의 속성, 변환 등을 보완

→ 보안, 데이터 검증, 캐싱, 로깅에 사용

(프록시 서버로도 활용함)

### 프록시 서버

서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킴

### nginx

비동기 에빈트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버

주로 Node.js 서버 앞단의 프록시 서버로 활용

“you just may be hacked when some yet-unknown buffer overflow is discovered, Not that couldn’t happen behind nginx, but somehow having a proxy in front makes me happy.” -Ryan Dahl-

(”Node.js의 버퍼 오버플로우 취약점을 예방하기 위해서는 nginx를 프록시 서버로 앞단에 놓고 Node.js를 뒤쪽에 놓는 것이 좋다. -라이언 달(Node.js 창시자)-

> [사용하는 이유](https://blog.naver.com/gi_balja/223028077537)

    1. 높은 성능과 적은 메모리 사용
    2. 리버스 프록시 사용이 가능
    3. SSL 지원
    4. 데이터 압축
    5. 비동기 처리

→ 익명 사용자의 직접적인 서버로의 접근을 차단
→ 간접적으로 한 단계를 더 거침으로써 보안성을 더욱 강화할 수 있음

### 프록시 서버로 쓰는 CloudFlare

전 세계적으로 분산된 서버가 있고, 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스

> **CDN(Content Delivery Network)**
> 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에 콘텐츠를 캐싱 또는 배포하는 서버 네트워크
> 이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드하는 시간을 줄일 수 있음.

추가적으로 `DDOS 공격 방어`, `HTTPS 구축`이 있음

#### DDOS 공격 방어

DDOS : 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형

CloudFlare는 시스템을 통해 오는 트래픽을 자동으로 차단함.

거대한 네트워크 용량과 캐싱 전략으로 소규모 DDOS 공격은 쉽게 막아내고 이러한 공격에 대한 방화벽 대시보드도 제공함.

#### HTTPS 구축

CloudFlare를 사용하면 별도의 인증서 설치 없이 쉽게 HTTPS를 구축할 수 있음.

**웹 서버 앞단에 두어 프록시 서버로 쓰기에 가능한 것임**

#### DDOS 공격 방어

DDOS : 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형

CloudFlare는 시스템을 통해 오는 트래픽을 자동으로 차단함.

거대한 네트워크 용량과 캐싱 전략으로 소규모 DDOS 공격은 쉽게 막아내고 이러한 공격에 대한 방화벽 대시보드도 제공함.

#### HTTPS 구축

CloudFlare를 사용하면 별도의 인증서 설치 없이 쉽게 HTTPS를 구축할 수 있음.

### CORS와 프론트엔드의 프록시 서버

**\*\***\*\***\*\***CORS(Cross-Origin Resource Sharing) :**\*\***\*\***\*\*** 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘

- 오리진

프로토콜, 호스트 이름, 포트의 조합

Ex) `https://hyuri.com:8080/test`에서 오리진은 `https://hyuri.com:8080`를 뜻 함.

프론트엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 CORS 에러를 마주치는데, 이를 해결하기 위해 프론트 엔드에서 프록시 서버를 만들기도 함.

Ex)

프론트엔드에서는 127.0.0.1:3000으로 테스팅할 때 백엔드는 127.0.0.1:8000이라면 CORS 에러가 발생함.

이때 프록시 서버를 둬서 프론트엔드 서버에서 요청되는 오리진은 1.1.1.1:8000으로 바꾼다.

`127.0.0.1` : 루프백 IP, 본인 PC의 IP를 뜻하며, DNS를 타지 않고 바로 본인 PC로 연결

프론트 서버 앞단에 프록시 서버를 놓고 /api 요청을 하면 CORS 에러 해결 및 다양한 API 서버와의 통신도 매끄럽게 할 수 있음.
